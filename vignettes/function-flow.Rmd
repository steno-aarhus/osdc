---
title: "Function flow"
output: rmarkdown::html_vignette
bibliography: references.bib
csl: vancouver.csl
vignette: >
  %\VignetteIndexEntry{Function flow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

This vignette describes the function conventions and function flow of
the osdc package. The function convention sections go over how we name
functions and how we structure them in terms of input and output. The
function flow describes the functions within the package, both internal
and user-facing, which data sources they rely on, and how they are
connected to each other. First, the functions for classifying diabetes
status are presented, followed by the functions for classifying the
diabetes type.

## Function conventions

The below conventions are *ideals* only, to be used as a guidelines to
help with development and understanding of the code. They are not hard
rules.

### Naming

-   First word is an action verb, later words are objects or conditions.
-   Exclusion criteria are prefixed with `exclude_`.
-   Inclusion criteria are prefixed with `include_`.
-   Helpers that get or extract a condition (e.g., "pregnancy" or "date
    of visit") are prefixed with `get_`.
-   Helpers that drop or keep a specific condition are prefixed with
    `drop_` or `keep_` (e.g., "first visit date to maternal care for
    pregnancy after 40 weeks"). These types of helpers likely are
    contained in the `get_` functions.
-   Helpers that join registers or output of other functions are
    prefixed with `join_`.

### Input and output

-   Few arguments, with one or two core required argument.
-   `include_` functions take a register as the first argument.
    -   One input register database at a time.
-   `exclude_` functions can take a register as the first argument or
    take the output from an `include_` function.
-   Second argument can be an output data from another function.

## Function flow

The osdc package contains one main function that classifies individuals
into those with either type 1 or type 2 diabetes using the Danish
registers: `classify_diabetes()`. This function classifies those with
diabetes (type 1 or 2) based on the Danish registers described in the
`vignette("design")` and `vignette("data-sources")`. All data sources
are used as input for this function. The specific inclusion and
exclusion details are also described in the `vignette("design")`.

This results in the functionality flow for classifying diabetes status
seen below. This flow can be divided into two sections: extracting the
diabetes population and classifying diabetes type which we will detail
in the following sections.

All functions take a `data.frame` type object as input and outputs the
same type of object as the input object (a `data.frame` type). For
instance, if the input is a `data.table` object, the output will also be
a `data.table`.

![Flow of functions, as well as their required input registers, for
classifying diabetes status using the osdc package. Light blue and
orange boxes represent filtering functions (inclusion and exclusion
events, respectively). Uncoloured boxes are helper functions that get or
extract a condition or joins data or function
outputs.](images/function-flow.png)

## Population extraction

In the following sections, we describe the functions used to extract the
diabetes population from the Danish registers. The functions are divided
into inclusion and exclusion events, and the final diagnosis date is
calculated based on these events.

![Flow of functions, as well as their required input registers, for
extracting the population with diabetes using the osdc package. Light
blue and orange boxes represent filtering functions (inclusion and
exclusion events, respectively). Uncoloured boxes are helper functions
that get or extract a condition or joins data or function
outputs.](images/function-flow-population.png)

### Inclusion events

```{r, include=FALSE}
library(dplyr)
library(osdc)
```

#### Hospital diagnoses

**Joining LPR2 and LPR3 data**

The helper functions `join_lpr2()` and `join_lpr3()` join records of
diagnoses to administrative information in LPR2-formatted and
LPR3-formatted data, respectively.

`join_lpr2()` takes `lpr_diag` and `lpr_adm` as inputs, filters to the
necessary diagnoses (`c_diag` starting with "DO", "DZ3", "DE1[0-4]",
"249", or "250"), joins the required information by record number
(`recnum`), and outputs a `data.frame` with the following variables:

-   identifier variable (`pnr`)
-   date (originally `d_inddto`, renamed to `date`)
-   department specialty (`c_spec`)
-   diagnosis code (`c_diag`)
-   diagnosis type (`c_diagtype`)

`join_lpr3()` takes `diagnoser` and `kontakter` as inputs, filters to
the necessary diagnoses (`diagnosekode` starting with "DO", "DZ3", or
"DE1[0-4]"), joins the required information by record number
(`dw_ek_kontakt`), and outputs a `data.frame` with the following
variables:

-   identifier variable (`cpr`)
-   date (`dato_start`)
-   department specialty (`hovedspeciale_ans`)
-   diagnosis code (`diagnosekode`)
-   diagnosis type (`diagnosetype`)
-   diagnosis retracted (`senere_afkraeftet`)

These outputs are passed to `include_diabetes_diagnoses()` (and to
`get_pregnancy_dates()`, see exclusion events) for further processing
below.

**Processing of diabetes diagnoses**

The function `include_diabetes_diagnoses()` uses the hospital contacts
from LPR2 and LPR3 to include all dates of diabetes diagnoses to use for
inclusion, as well as additional information needed to classify diabetes
type. Diabetes diagnoses from both ICD-8 and ICD-10 are included.

The function takes the outputs of `join_lpr2()` and `join_lpr3()` as
inputs and processes each input separately to generate the following
internal variables:

-   LPR2-data:
    -   `pnr`: identifier variable
    -   `do_diagnosis`: include all diabetes diagnoses, registered as
        primary (A) or secondary (B) diagnoses, regardless of type or
        department: `c_diag` starts with "DE1[0-4]", "249", or "250" and
        `c_diagtype` is either "A" or "B"
    -   `is_primary`: Define whether the diagnosis was a primary
        diagnosis (`c_diagtype` == "A")
    -   `is_t1d`: Define whether the diagnosis was T1D-specific
        (`c_diag` starts with "DE10" or "249")
    -   `is_t2d`: Define whether the diagnosis was T2D-specific
        (`c_diag` starts with "DE11" or "250")
    -   `department`: Define whether the diagnosis was made made by an
        endocrinological (`c_spec` == 8) or other medical department
        (`c_spec` \< 8 or 9-30)
-   LPR3:
    -   `pnr`: identifier variable
    -   `do_diagnosis`: include all diabetes diagnoses, registered as
        primary (A) or secondary (B) diagnoses, regardless of type or
        department: `diagnosekode` starts with "DE1[0-4]" and
        `diagnosetype` is either "A" or "B", but exclude retracted
        diagnoses (`senere_afkraeftet` == "Ja")
    -   `is_primary`: Define whether the diagnosis was a primary
        diagnosis (`diagnosetype` == "A")
    -   `is_t1d`: Define whether the diagnosis was T1D-specific
        (`diagnosekode` starts with "DE10")
    -   `is_t2d`: Define whether the diagnosis was T2D-specific
        (`diagnosekode` starts with "DE11")
    -   `department`: Define whether the diagnosis was made made by an
        endocrinological (`hovedspeciale_ans` == "medicinsk
        endokrinologi") or other medical department (`hovedspeciale_ans`
        either "Blandet medicin og kirurgi", "Intern medicin",
        "Geriatri", "Hepatologi", "HÃ¦matologi", "Infektionsmedicin",
        "Kardiologi", "Medicinsk allergologi", "Medicinsk
        gastroenterologi", "Medicinsk lungesygdomme", "Nefrologi",
        "Reumatologi", "Palliativ medicin", "Akut medicin",
        "Dermato-venerologi", "Neurologi", "Onkologi", "Fysiurgi", or
        "Tropemedicin")

These intermediate results are combined for further processing, and
`include_diabetes_diagnoses()` outputs a single `data.frame` with the
following variables (up to two rows per individual):

-   identifier variable (`pnr`)
-   dates of the first and second hospital diabetes diagnosis
    (`diagnosis_dates`)
-   number of type 1 diabetes-specific primary diagnosis codes from
    endocrinological departments (`n_t1d_endo`)
-   number of type 2 diabetes-specific primary diagnosis codes from
    endocrinological departments (`n_t2d_endo`)
-   number of type 1 diabetes-specific primary diagnosis codes from
    medical departments (`n_t1d_medical`)
-   number of type 2 diabetes-specific primary diagnosis codes from
    medical departments (`n_t2d_medical`)

The output is passed to the `get_diagnosis_date()` function for the
final step of the inclusion process and is subsequently used to classify
diabetes type.

#### Diabetes-specific podiatrist services

The function `include_podiatrist_services()` uses `sysi` or `sssy` as
input to extract the dates of all diabetes-specific podiatrist services.

These dates are extracted by filtering values beginning with "54" in the
`speciale` variable of the `sssy` and `sysi` registers by default
(alternatively, the function can take the `spec2` variable as input
instead, if that is the data available to the user). In addition,
services provided to a child of the individual (`barnmak` != 0) are
excluded using the `barnmak` variable. An internal helper function
`get_unique_honuge_dates()` is applied to generate a proper date
variable based on the year-week (wwyy-formatted) variable (`honuge`)
found in the raw data, and de-duplicates multiple services registered on
the same date.

`include_podiatrist_services()` outputs a 3-column data frame with one
row for each individual, containing the following variables:

-   identifier variable (`pnr`)
-   the date of the first diabetes-specific podiatrist record
    (`do_podiatrist_1`)
-   the date of the second diabetes-specific podiatrist record
    (`do_podiatrist_2`)

The output is passed to the `get_diagnosis_date()` function for the
final step of the inclusion process.

#### HbA1c tests above the diagnosis cut-off value (48 mmol/mol or 6.5%)

The function `include_hba1c()` uses `lab_forsker` as the input data to
extract the dates of all elevated HbA1c test results, using the
appropriate cut-offs:

-   IFCC units: `analysiscode` NPU27300, any `value` $\geq$ 48 mmol/mol
-   DCCT units: `analysiscode` NPU03835: any `value` $\geq$ 6.5% .

```{r, echo=FALSE}
algorithm |> 
	filter(name=="hba1c") |>
	knitr::kable(caption = "Algorithm used in the implementation for including HbA1c.")
```

Multiple elevated results on the same day within each individual are
deduplicated, to account for the same test result often being reported
twice (one for IFCC, one for DCCT units).

`include_hba1c()` outputs a 2-column data frame containing the following
variables:

-   identifier variable (`pnr`)
-   the dates of all elevated HbA1c test results (`dates`).

The output is passed to the `exclude_pregnancy()` function for censoring
of elevated results due to potential gestational diabetes (see below).

#### GLD purchases

The function `include_gld_purchases()` uses `lmdb` to extract the dates
of all GLD purchases.

These dates are extracted by including all values beginning with "A10"
in the `atc` variable of the `lmdb` register. Since the diagnosis code
data on pregnancies (see below) is insufficient to perform censoring
prior to 1997, `include_gld_purchases()` only extracts dates from 1997
onward by default (if Medical Birth Register data is available to use
for censoring, the extraction window can be extended).

This function outputs a `data.frame` with the following variables needed
later in the classification part of the function flow:

-   identifier variable (`pnr`)
-   date (`eksd`)
-   type of drug (`atc`)
-   amount purchased (`volume` and `apk`)
-   indication code (`indo`)

These events are then passed to a chain of exclusion functions:
`exclude_wld_purchases()`, `exclude_potential_pcos()`,
`exclude_pregnancy()` described in the sections below.

After these exclusion functions have been applied, the output serves as
inputs to two sets of functions:

1.  the `get_diagnosis_date()` function for the final step of the
    inclusion process.
2.  the `get_only_insulin_purchases()`,
    `get_insulin_purchases_within_180_days()`, and
    `get_insulin_is_two_thirds_of_gld_doses()` helper functions for the
    classification of diabetes type.

### Exclusion events

#### Metformin purchases potentially for the treatment of polycystic ovary syndrome

The function `exclude_potential_pcos()` takes the output from
`include_gld_purchases()` and `bef` (information on sex and date of
birth) as inputs and censors (filters out) all purchases of metformin in
women below age 40 at the date of purchase (`atc` = "A10BA02" & `sex` =
"woman" & date at purchase (`date`-`date_of_birth`) \< 40 years) or an
indication code suggesting treatment of polycystic ovary syndrome (`atc`
= "A10BA02" & `sex` = "woman" & `indication_code` either "0000092",
"0000276", "0000781").

After these exclusions are made, the output is passed to
`exclude_pregnancy()` for further censoring, described below:

#### HbA1c tests and GLD purchases during pregnancy

The function `exclude_pregnancy()` uses diagnoses from LPR2 or LPR3 as
input and is used to exclude both HbA1c tests and GLD purchases during
pregnancy, as these may be due to gestational diabetes, rather than type
1 or type 2 diabetes.

Internally, this relies on the function `get_pregnancy_dates()` that
uses diagnoses registered in the National Patient Register to extract
the dates of all pregnancy ending (live births or miscarriages). These
are identified by filtering values beginning with "DO0[0-6]", "DO8[0-4]"
or "DZ3[37]" in the `c_diag` variable in the LPR2 data (`diagnosekode`
in LPR3 data).

<!-- TODO: Add details on how this filtering should be done -->

### Get diagnosis date

The function `get_diagnosis_date()` combines the outputs from the
inclusion and exclusion functions to get the final diagnosis date.
Initially, it drops the first inclusion and exclusion events from the
function outputs with the helper `drop_first_event()`, so that only
those with two or more events are kept. This is then used to assign an
initial diagnosis according to OSDC. Then, all the outputs are joined
together with `join_diagnosis_dates()`.

Finally, the dates outside of the data coverage period are dropped with
`drop_diagnosis_dates_outside_coverage()` to end with a final diagnosis
date. For details on this censoring based on periods with insufficient
data coverage, see the `vignette("design")`.

### Classifying the diabetes type

The next step of the OSDC algorithm classifies individuals from the
extracted diabetes population as having either T1D or T2D. As described
in the `vignette("design")`, individuals not classified as T1D cases are
classified as T2D cases.

The output is a `data.frame` that includes one row per individual in the
diabetes population: one column with their PNR, two columns with
inclusion dates (one "stable" date and one "raw" date - see the
`vignette("design")` for an elaboration on what that entails), and one
column with the diabetes type.

<!-- TODO: add a link to the specific section where this is described -->

![Flow of functions for classifying diabetes status using the `osdc`
package.](images/function-flow-classification.png)

#### Type 1 classification

The details for the classification of type 1 diabetes is described in
`vignette("design")`. To classify whether an individual has T1D, the
OSDC algorithm includes the following criteria:

1.  `get_t1d_primary_diagnosis()`, which relies on the hospital
    diagnoses extracted from `lpr_diag` (LPR2) and `diagnoser` (LPR3) in
    the previous steps.
2.  `get_only_insulin_purchases()` which relies on the GLD purchases
    from LÃ¦gemiddelsdatabasen to get patients where all GLD purchases
    are insulin only.
3.  `get_majority_of_t1d_diagnoses()` (as compared to T2D diagnoses)
    which again relies on primary hospital diagnoses from LPR.
4.  `get_insulin_purchase_within_180_days()` which relies on both
    diagnosis from LPR and GLD purchases from LÃ¦gemiddelsdatabasen.
5.  `get_insulin_is_two_thirds_of_gld_doses` which relies on the GLD
    purchases from LÃ¦gemiddelsdatabasen.

Note the following hierarchy in first function above: First, the
function checks whether the individual has primary diagnoses from
endocrinological specialty. If that's the case for a given person, the
check of whether they have a majority of T1D primary diagnoses are based
on data from endocrinological specialty. If that's not the case, the
check will be based on primary diagnoses from medical specialties.

#### Type 2 classification

As described in the `vignette("design")`, individuals not classified as
type 1 cases are classified as type 2 cases.

## Output

The output of the OSDC algorithm is a `data.frame` which includes four
columns:

1.  **PNR**: The pseudonymised social security number of individuals in
    the diabetes population (one row per individual)
2.  **stable_inclusion_date**: The *stable* inclusion date (i.e., the
    raw date mutated so only individuals included in the time-period
    where data coverage is sufficient to make incident cases
    reliable)[^1]
    <!-- TODO: Specify this time-period: e.g., later than 1997 -->
3.  **raw_inclusion_date**: The *raw* inclusion date (i.e., the date of
    the second inclusion event as described in the [Extracting the
    diabetes population](#extracting-diabetes-population) section above)
4.  **diabetes_type** The classified diabetes type

[^1]: For more information on the "raw" versus "stable" inclusion date,
    see `vignette("design")`.

<!-- TODO: Make sure this is the correct link - and add a link specific to the specific section where this is described -->

For an example, see below.

| PNR        | stable_inclusion_date | raw_inclusion_date | diabetes_type |
|------------|-----------------------|--------------------|---------------|
| 0000000001 | 2020-01-01            | 2020-01-01         | T1D           |
| 0000000004 | NULL                  | 1995-04-19         | T2D           |

: Example rows of the `data.frame` output of the osdc package.

The individuals `0000000001` and `0000000004` have been classified as
having diabetes (`T1D` and `T2D`, respectively). `0000000004` is
classified as having type 1 diabetes (T1D) with an inclusion date of
`2020-01-01`. Since this date is within a time-period of sufficient data
coverage, the column `stable_inclusion_date` is populated with the same
date as `raw_inclusion_date`.

The individual in the second row, `0000000004` is classified as having
type 2 diabetes `T2D` with an inclusion date of `1995-19-04`. Since 1995
is within a time-period of insufficient data coverage,
`stable_inclusion_date` is `NULL`. However, `raw_inclusion_date` still
contains the inclusion date of this individual.

<!-- TODO: Specify the "stable" time-period: e.g., later than 1997 -->
